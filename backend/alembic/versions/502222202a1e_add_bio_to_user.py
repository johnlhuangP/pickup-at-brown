"""add bio to user

Revision ID: 502222202a1e
Revises: e6c94f5cc8ab
Create Date: 2024-12-05 13:38:33.845701

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = '502222202a1e'
down_revision: Union[str, None] = 'e6c94f5cc8ab'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('messages', schema='realtime')
    op.drop_table('s3_multipart_uploads_parts', schema='storage')
    op.drop_index('mfa_challenge_created_at_idx', table_name='mfa_challenges', schema='auth')
    op.drop_table('mfa_challenges', schema='auth')
    op.drop_index('sso_providers_resource_id_idx', table_name='sso_providers', schema='auth')
    op.drop_table('sso_providers', schema='auth')
    op.drop_index('audit_logs_instance_id_idx', table_name='audit_log_entries', schema='auth')
    op.drop_table('audit_log_entries', schema='auth')
    op.drop_table('schema_migrations', schema='auth')
    op.drop_table('instances', schema='auth')
    op.drop_index('saml_relay_states_created_at_idx', table_name='saml_relay_states', schema='auth')
    op.drop_index('saml_relay_states_for_email_idx', table_name='saml_relay_states', schema='auth')
    op.drop_index('saml_relay_states_sso_provider_id_idx', table_name='saml_relay_states', schema='auth')
    op.drop_table('saml_relay_states', schema='auth')
    op.drop_index('identities_email_idx', table_name='identities', schema='auth')
    op.drop_index('identities_user_id_idx', table_name='identities', schema='auth')
    op.drop_table('identities', schema='auth')
    op.drop_table('mfa_amr_claims', schema='auth')
    op.drop_index('secrets_name_idx', table_name='secrets', schema='vault', postgresql_where='(name IS NOT NULL)')
    op.drop_table('secrets', schema='vault')
    op.drop_index('confirmation_token_idx', table_name='users', schema='auth', postgresql_where="((confirmation_token)::text !~ '^[0-9 ]*$'::text)")
    op.drop_index('email_change_token_current_idx', table_name='users', schema='auth', postgresql_where="((email_change_token_current)::text !~ '^[0-9 ]*$'::text)")
    op.drop_index('email_change_token_new_idx', table_name='users', schema='auth', postgresql_where="((email_change_token_new)::text !~ '^[0-9 ]*$'::text)")
    op.drop_index('reauthentication_token_idx', table_name='users', schema='auth', postgresql_where="((reauthentication_token)::text !~ '^[0-9 ]*$'::text)")
    op.drop_index('recovery_token_idx', table_name='users', schema='auth', postgresql_where="((recovery_token)::text !~ '^[0-9 ]*$'::text)")
    op.drop_index('users_email_partial_key', table_name='users', schema='auth', postgresql_where='(is_sso_user = false)')
    op.drop_index('users_instance_id_email_idx', table_name='users', schema='auth')
    op.drop_index('users_instance_id_idx', table_name='users', schema='auth')
    op.drop_index('users_is_anonymous_idx', table_name='users', schema='auth')
    op.drop_table('users', schema='auth')
    op.drop_index('idx_multipart_uploads_list', table_name='s3_multipart_uploads', schema='storage')
    op.drop_table('s3_multipart_uploads', schema='storage')
    op.drop_table('schema_migrations', schema='realtime')
    op.drop_index('ix_realtime_subscription_entity', table_name='subscription', schema='realtime')
    op.drop_index('subscription_subscription_id_entity_filters_key', table_name='subscription', schema='realtime')
    op.drop_table('subscription', schema='realtime')
    op.drop_index('sessions_not_after_idx', table_name='sessions', schema='auth')
    op.drop_index('sessions_user_id_idx', table_name='sessions', schema='auth')
    op.drop_index('user_id_created_at_idx', table_name='sessions', schema='auth')
    op.drop_table('sessions', schema='auth')
    op.drop_index('bucketid_objname', table_name='objects', schema='storage')
    op.drop_index('idx_objects_bucket_id_name', table_name='objects', schema='storage')
    op.drop_index('name_prefix_search', table_name='objects', schema='storage')
    op.drop_table('objects', schema='storage')
    op.drop_index('flow_state_created_at_idx', table_name='flow_state', schema='auth')
    op.drop_index('idx_auth_code', table_name='flow_state', schema='auth')
    op.drop_index('idx_user_id_auth_method', table_name='flow_state', schema='auth')
    op.drop_table('flow_state', schema='auth')
    op.drop_index('saml_providers_sso_provider_id_idx', table_name='saml_providers', schema='auth')
    op.drop_table('saml_providers', schema='auth')
    op.drop_index('one_time_tokens_relates_to_hash_idx', table_name='one_time_tokens', schema='auth', postgresql_using='hash')
    op.drop_index('one_time_tokens_token_hash_hash_idx', table_name='one_time_tokens', schema='auth', postgresql_using='hash')
    op.drop_index('one_time_tokens_user_id_token_type_key', table_name='one_time_tokens', schema='auth')
    op.drop_table('one_time_tokens', schema='auth')
    op.drop_index('bname', table_name='buckets', schema='storage')
    op.drop_table('buckets', schema='storage')
    op.drop_table('migrations', schema='storage')
    op.drop_index('factor_id_created_at_idx', table_name='mfa_factors', schema='auth')
    op.drop_index('mfa_factors_user_friendly_name_unique', table_name='mfa_factors', schema='auth', postgresql_where="(TRIM(BOTH FROM friendly_name) <> ''::text)")
    op.drop_index('mfa_factors_user_id_idx', table_name='mfa_factors', schema='auth')
    op.drop_index('unique_phone_factor_per_user', table_name='mfa_factors', schema='auth')
    op.drop_table('mfa_factors', schema='auth')
    op.drop_index('refresh_tokens_instance_id_idx', table_name='refresh_tokens', schema='auth')
    op.drop_index('refresh_tokens_instance_id_user_id_idx', table_name='refresh_tokens', schema='auth')
    op.drop_index('refresh_tokens_parent_idx', table_name='refresh_tokens', schema='auth')
    op.drop_index('refresh_tokens_session_id_revoked_idx', table_name='refresh_tokens', schema='auth')
    op.drop_index('refresh_tokens_updated_at_idx', table_name='refresh_tokens', schema='auth')
    op.drop_table('refresh_tokens', schema='auth')
    op.drop_index('sso_domains_domain_idx', table_name='sso_domains', schema='auth')
    op.drop_index('sso_domains_sso_provider_id_idx', table_name='sso_domains', schema='auth')
    op.drop_table('sso_domains', schema='auth')
    op.add_column('users', sa.Column('bio', sa.String(), nullable=True))
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('users', 'bio')
    op.create_table('sso_domains',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('sso_provider_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('domain', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.CheckConstraint('char_length(domain) > 0', name='domain not empty'),
    sa.ForeignKeyConstraint(['sso_provider_id'], ['auth.sso_providers.id'], name='sso_domains_sso_provider_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='sso_domains_pkey'),
    schema='auth',
    comment='Auth: Manages SSO email address domain mapping to an SSO Identity Provider.'
    )
    op.create_index('sso_domains_sso_provider_id_idx', 'sso_domains', ['sso_provider_id'], unique=False, schema='auth')
    op.create_index('sso_domains_domain_idx', 'sso_domains', [sa.text('lower(domain)')], unique=True, schema='auth')
    op.create_table('refresh_tokens',
    sa.Column('instance_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('id', sa.BIGINT(), autoincrement=True, nullable=False),
    sa.Column('token', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('user_id', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('revoked', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('parent', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('session_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['session_id'], ['auth.sessions.id'], name='refresh_tokens_session_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='refresh_tokens_pkey'),
    sa.UniqueConstraint('token', name='refresh_tokens_token_unique'),
    schema='auth',
    comment='Auth: Store of tokens used to refresh JWT tokens once they expire.'
    )
    op.create_index('refresh_tokens_updated_at_idx', 'refresh_tokens', [sa.text('updated_at DESC')], unique=False, schema='auth')
    op.create_index('refresh_tokens_session_id_revoked_idx', 'refresh_tokens', ['session_id', 'revoked'], unique=False, schema='auth')
    op.create_index('refresh_tokens_parent_idx', 'refresh_tokens', ['parent'], unique=False, schema='auth')
    op.create_index('refresh_tokens_instance_id_user_id_idx', 'refresh_tokens', ['instance_id', 'user_id'], unique=False, schema='auth')
    op.create_index('refresh_tokens_instance_id_idx', 'refresh_tokens', ['instance_id'], unique=False, schema='auth')
    op.create_table('mfa_factors',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('friendly_name', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('factor_type', postgresql.ENUM('totp', 'webauthn', 'phone', name='factor_type', schema='auth'), autoincrement=False, nullable=False),
    sa.Column('status', postgresql.ENUM('unverified', 'verified', name='factor_status', schema='auth'), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('secret', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('phone', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('last_challenged_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('web_authn_credential', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('web_authn_aaguid', sa.UUID(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name='mfa_factors_user_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='mfa_factors_pkey'),
    sa.UniqueConstraint('last_challenged_at', name='mfa_factors_last_challenged_at_key'),
    schema='auth',
    comment='auth: stores metadata about factors',
    postgresql_ignore_search_path=False
    )
    op.create_index('unique_phone_factor_per_user', 'mfa_factors', ['user_id', 'phone'], unique=True, schema='auth')
    op.create_index('mfa_factors_user_id_idx', 'mfa_factors', ['user_id'], unique=False, schema='auth')
    op.create_index('mfa_factors_user_friendly_name_unique', 'mfa_factors', ['friendly_name', 'user_id'], unique=True, schema='auth', postgresql_where="(TRIM(BOTH FROM friendly_name) <> ''::text)")
    op.create_index('factor_id_created_at_idx', 'mfa_factors', ['user_id', 'created_at'], unique=False, schema='auth')
    op.create_table('migrations',
    sa.Column('id', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('name', sa.VARCHAR(length=100), autoincrement=False, nullable=False),
    sa.Column('hash', sa.VARCHAR(length=40), autoincrement=False, nullable=False),
    sa.Column('executed_at', postgresql.TIMESTAMP(), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='migrations_pkey'),
    sa.UniqueConstraint('name', name='migrations_name_key'),
    schema='storage'
    )
    op.create_table('buckets',
    sa.Column('id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('name', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('owner', sa.UUID(), autoincrement=False, nullable=True, comment='Field is deprecated, use owner_id instead'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('public', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=True),
    sa.Column('avif_autodetection', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=True),
    sa.Column('file_size_limit', sa.BIGINT(), autoincrement=False, nullable=True),
    sa.Column('allowed_mime_types', postgresql.ARRAY(sa.TEXT()), autoincrement=False, nullable=True),
    sa.Column('owner_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='buckets_pkey'),
    schema='storage',
    postgresql_ignore_search_path=False
    )
    op.create_index('bname', 'buckets', ['name'], unique=True, schema='storage')
    op.create_table('one_time_tokens',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('token_type', postgresql.ENUM('confirmation_token', 'reauthentication_token', 'recovery_token', 'email_change_token_new', 'email_change_token_current', 'phone_change_token', name='one_time_token_type', schema='auth'), autoincrement=False, nullable=False),
    sa.Column('token_hash', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('relates_to', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.CheckConstraint('char_length(token_hash) > 0', name='one_time_tokens_token_hash_check'),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name='one_time_tokens_user_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='one_time_tokens_pkey'),
    schema='auth'
    )
    op.create_index('one_time_tokens_user_id_token_type_key', 'one_time_tokens', ['user_id', 'token_type'], unique=True, schema='auth')
    op.create_index('one_time_tokens_token_hash_hash_idx', 'one_time_tokens', ['token_hash'], unique=False, schema='auth', postgresql_using='hash')
    op.create_index('one_time_tokens_relates_to_hash_idx', 'one_time_tokens', ['relates_to'], unique=False, schema='auth', postgresql_using='hash')
    op.create_table('saml_providers',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('sso_provider_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('entity_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('metadata_xml', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('metadata_url', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('attribute_mapping', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('name_id_format', sa.TEXT(), autoincrement=False, nullable=True),
    sa.CheckConstraint('char_length(entity_id) > 0', name='entity_id not empty'),
    sa.CheckConstraint('char_length(metadata_xml) > 0', name='metadata_xml not empty'),
    sa.CheckConstraint('metadata_url = NULL::text OR char_length(metadata_url) > 0', name='metadata_url not empty'),
    sa.ForeignKeyConstraint(['sso_provider_id'], ['auth.sso_providers.id'], name='saml_providers_sso_provider_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='saml_providers_pkey'),
    sa.UniqueConstraint('entity_id', name='saml_providers_entity_id_key'),
    schema='auth',
    comment='Auth: Manages SAML Identity Provider connections.'
    )
    op.create_index('saml_providers_sso_provider_id_idx', 'saml_providers', ['sso_provider_id'], unique=False, schema='auth')
    op.create_table('flow_state',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('auth_code', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('code_challenge_method', postgresql.ENUM('s256', 'plain', name='code_challenge_method', schema='auth'), autoincrement=False, nullable=False),
    sa.Column('code_challenge', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('provider_type', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('provider_access_token', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('provider_refresh_token', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('authentication_method', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('auth_code_issued_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='flow_state_pkey'),
    schema='auth',
    comment='stores metadata for pkce logins',
    postgresql_ignore_search_path=False
    )
    op.create_index('idx_user_id_auth_method', 'flow_state', ['user_id', 'authentication_method'], unique=False, schema='auth')
    op.create_index('idx_auth_code', 'flow_state', ['auth_code'], unique=False, schema='auth')
    op.create_index('flow_state_created_at_idx', 'flow_state', [sa.text('created_at DESC')], unique=False, schema='auth')
    op.create_table('objects',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('bucket_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('name', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('owner', sa.UUID(), autoincrement=False, nullable=True, comment='Field is deprecated, use owner_id instead'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('last_accessed_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=True),
    sa.Column('metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('path_tokens', postgresql.ARRAY(sa.TEXT()), sa.Computed("string_to_array(name, '/'::text)", persisted=True), autoincrement=False, nullable=True),
    sa.Column('version', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('owner_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('user_metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['bucket_id'], ['storage.buckets.id'], name='objects_bucketId_fkey'),
    sa.PrimaryKeyConstraint('id', name='objects_pkey'),
    schema='storage'
    )
    op.create_index('name_prefix_search', 'objects', ['name'], unique=False, schema='storage')
    op.create_index('idx_objects_bucket_id_name', 'objects', ['bucket_id', 'name'], unique=False, schema='storage')
    op.create_index('bucketid_objname', 'objects', ['bucket_id', 'name'], unique=True, schema='storage')
    op.create_table('sessions',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('factor_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('aal', postgresql.ENUM('aal1', 'aal2', 'aal3', name='aal_level', schema='auth'), autoincrement=False, nullable=True),
    sa.Column('not_after', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True, comment='Auth: Not after is a nullable column that contains a timestamp after which the session should be regarded as expired.'),
    sa.Column('refreshed_at', postgresql.TIMESTAMP(), autoincrement=False, nullable=True),
    sa.Column('user_agent', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('ip', postgresql.INET(), autoincrement=False, nullable=True),
    sa.Column('tag', sa.TEXT(), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name='sessions_user_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='sessions_pkey'),
    schema='auth',
    comment='Auth: Stores session data associated to a user.',
    postgresql_ignore_search_path=False
    )
    op.create_index('user_id_created_at_idx', 'sessions', ['user_id', 'created_at'], unique=False, schema='auth')
    op.create_index('sessions_user_id_idx', 'sessions', ['user_id'], unique=False, schema='auth')
    op.create_index('sessions_not_after_idx', 'sessions', [sa.text('not_after DESC')], unique=False, schema='auth')
    op.create_table('subscription',
    sa.Column('id', sa.BIGINT(), sa.Identity(always=True, start=1, increment=1, minvalue=1, maxvalue=9223372036854775807, cycle=False, cache=1), autoincrement=True, nullable=False),
    sa.Column('subscription_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('entity', postgresql.REGCLASS(), autoincrement=False, nullable=False),
    sa.Column('filters', sa.NullType(), server_default=sa.text("'{}'::realtime.user_defined_filter[]"), autoincrement=False, nullable=False),
    sa.Column('claims', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False),
    sa.Column('claims_role', sa.NullType(), sa.Computed("realtime.to_regrole((claims ->> 'role'::text))", persisted=True), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(), server_default=sa.text("timezone('utc'::text, now())"), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='pk_subscription'),
    schema='realtime'
    )
    op.create_index('subscription_subscription_id_entity_filters_key', 'subscription', ['subscription_id', 'entity', 'filters'], unique=True, schema='realtime')
    op.create_index('ix_realtime_subscription_entity', 'subscription', ['entity'], unique=False, schema='realtime')
    op.create_table('schema_migrations',
    sa.Column('version', sa.BIGINT(), autoincrement=False, nullable=False),
    sa.Column('inserted_at', postgresql.TIMESTAMP(precision=0), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('version', name='schema_migrations_pkey'),
    schema='realtime'
    )
    op.create_table('s3_multipart_uploads',
    sa.Column('id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('in_progress_size', sa.BIGINT(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('upload_signature', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('bucket_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('key', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('version', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('owner_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('user_metadata', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['bucket_id'], ['storage.buckets.id'], name='s3_multipart_uploads_bucket_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='s3_multipart_uploads_pkey'),
    schema='storage',
    postgresql_ignore_search_path=False
    )
    op.create_index('idx_multipart_uploads_list', 's3_multipart_uploads', ['bucket_id', 'key', 'created_at'], unique=False, schema='storage')
    op.create_table('users',
    sa.Column('instance_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('aud', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('role', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('email', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('encrypted_password', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('email_confirmed_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('invited_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('confirmation_token', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('confirmation_sent_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('recovery_token', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('recovery_sent_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('email_change_token_new', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('email_change', sa.VARCHAR(length=255), autoincrement=False, nullable=True),
    sa.Column('email_change_sent_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('last_sign_in_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('raw_app_meta_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('raw_user_meta_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('is_super_admin', sa.BOOLEAN(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('phone', sa.TEXT(), server_default=sa.text('NULL::character varying'), autoincrement=False, nullable=True),
    sa.Column('phone_confirmed_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('phone_change', sa.TEXT(), server_default=sa.text("''::character varying"), autoincrement=False, nullable=True),
    sa.Column('phone_change_token', sa.VARCHAR(length=255), server_default=sa.text("''::character varying"), autoincrement=False, nullable=True),
    sa.Column('phone_change_sent_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('confirmed_at', postgresql.TIMESTAMP(timezone=True), sa.Computed('LEAST(email_confirmed_at, phone_confirmed_at)', persisted=True), autoincrement=False, nullable=True),
    sa.Column('email_change_token_current', sa.VARCHAR(length=255), server_default=sa.text("''::character varying"), autoincrement=False, nullable=True),
    sa.Column('email_change_confirm_status', sa.SMALLINT(), server_default=sa.text('0'), autoincrement=False, nullable=True),
    sa.Column('banned_until', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('reauthentication_token', sa.VARCHAR(length=255), server_default=sa.text("''::character varying"), autoincrement=False, nullable=True),
    sa.Column('reauthentication_sent_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('is_sso_user', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False, comment='Auth: Set this column to true when the account comes from SSO. These accounts can have duplicate emails.'),
    sa.Column('deleted_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('is_anonymous', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=False),
    sa.CheckConstraint('email_change_confirm_status >= 0 AND email_change_confirm_status <= 2', name='users_email_change_confirm_status_check'),
    sa.PrimaryKeyConstraint('id', name='users_pkey'),
    sa.UniqueConstraint('phone', name='users_phone_key'),
    schema='auth',
    comment='Auth: Stores user login data within a secure schema.',
    postgresql_ignore_search_path=False
    )
    op.create_index('users_is_anonymous_idx', 'users', ['is_anonymous'], unique=False, schema='auth')
    op.create_index('users_instance_id_idx', 'users', ['instance_id'], unique=False, schema='auth')
    op.create_index('users_instance_id_email_idx', 'users', ['instance_id', sa.text('lower(email::text)')], unique=False, schema='auth')
    op.create_index('users_email_partial_key', 'users', ['email'], unique=True, schema='auth', postgresql_where='(is_sso_user = false)')
    op.create_index('recovery_token_idx', 'users', ['recovery_token'], unique=True, schema='auth', postgresql_where="((recovery_token)::text !~ '^[0-9 ]*$'::text)")
    op.create_index('reauthentication_token_idx', 'users', ['reauthentication_token'], unique=True, schema='auth', postgresql_where="((reauthentication_token)::text !~ '^[0-9 ]*$'::text)")
    op.create_index('email_change_token_new_idx', 'users', ['email_change_token_new'], unique=True, schema='auth', postgresql_where="((email_change_token_new)::text !~ '^[0-9 ]*$'::text)")
    op.create_index('email_change_token_current_idx', 'users', ['email_change_token_current'], unique=True, schema='auth', postgresql_where="((email_change_token_current)::text !~ '^[0-9 ]*$'::text)")
    op.create_index('confirmation_token_idx', 'users', ['confirmation_token'], unique=True, schema='auth', postgresql_where="((confirmation_token)::text !~ '^[0-9 ]*$'::text)")
    op.create_table('secrets',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('name', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('description', sa.TEXT(), server_default=sa.text("''::text"), autoincrement=False, nullable=False),
    sa.Column('secret', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('key_id', sa.UUID(), server_default=sa.text('(pgsodium.create_key()).id'), autoincrement=False, nullable=True),
    sa.Column('nonce', postgresql.BYTEA(), server_default=sa.text('pgsodium.crypto_aead_det_noncegen()'), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['key_id'], ['pgsodium.key.id'], name='secrets_key_id_fkey'),
    sa.PrimaryKeyConstraint('id', name='secrets_pkey'),
    schema='vault',
    comment='Table with encrypted `secret` column for storing sensitive information on disk.'
    )
    op.create_index('secrets_name_idx', 'secrets', ['name'], unique=True, schema='vault', postgresql_where='(name IS NOT NULL)')
    op.create_table('mfa_amr_claims',
    sa.Column('session_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('authentication_method', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['session_id'], ['auth.sessions.id'], name='mfa_amr_claims_session_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='amr_id_pk'),
    sa.UniqueConstraint('session_id', 'authentication_method', name='mfa_amr_claims_session_id_authentication_method_pkey'),
    schema='auth',
    comment='auth: stores authenticator method reference claims for multi factor authentication'
    )
    op.create_table('identities',
    sa.Column('provider_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('user_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('identity_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=False),
    sa.Column('provider', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('last_sign_in_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('email', sa.TEXT(), sa.Computed("lower((identity_data ->> 'email'::text))", persisted=True), autoincrement=False, nullable=True, comment='Auth: Email is a generated column that references the optional email property in the identity_data'),
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['auth.users.id'], name='identities_user_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='identities_pkey'),
    sa.UniqueConstraint('provider_id', 'provider', name='identities_provider_id_provider_unique'),
    schema='auth',
    comment='Auth: Stores identities associated to a user.'
    )
    op.create_index('identities_user_id_idx', 'identities', ['user_id'], unique=False, schema='auth')
    op.create_index('identities_email_idx', 'identities', ['email'], unique=False, schema='auth')
    op.create_table('saml_relay_states',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('sso_provider_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('request_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('for_email', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('redirect_to', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('flow_state_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.CheckConstraint('char_length(request_id) > 0', name='request_id not empty'),
    sa.ForeignKeyConstraint(['flow_state_id'], ['auth.flow_state.id'], name='saml_relay_states_flow_state_id_fkey', ondelete='CASCADE'),
    sa.ForeignKeyConstraint(['sso_provider_id'], ['auth.sso_providers.id'], name='saml_relay_states_sso_provider_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='saml_relay_states_pkey'),
    schema='auth',
    comment='Auth: Contains SAML Relay State information for each Service Provider initiated login.'
    )
    op.create_index('saml_relay_states_sso_provider_id_idx', 'saml_relay_states', ['sso_provider_id'], unique=False, schema='auth')
    op.create_index('saml_relay_states_for_email_idx', 'saml_relay_states', ['for_email'], unique=False, schema='auth')
    op.create_index('saml_relay_states_created_at_idx', 'saml_relay_states', [sa.text('created_at DESC')], unique=False, schema='auth')
    op.create_table('instances',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('uuid', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('raw_base_config', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.PrimaryKeyConstraint('id', name='instances_pkey'),
    schema='auth',
    comment='Auth: Manages users across multiple sites.'
    )
    op.create_table('schema_migrations',
    sa.Column('version', sa.VARCHAR(length=255), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('version', name='schema_migrations_pkey'),
    schema='auth',
    comment='Auth: Manages updates to the auth system.'
    )
    op.create_table('audit_log_entries',
    sa.Column('instance_id', sa.UUID(), autoincrement=False, nullable=True),
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('payload', postgresql.JSON(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('ip_address', sa.VARCHAR(length=64), server_default=sa.text("''::character varying"), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', name='audit_log_entries_pkey'),
    schema='auth',
    comment='Auth: Audit trail for user actions.'
    )
    op.create_index('audit_logs_instance_id_idx', 'audit_log_entries', ['instance_id'], unique=False, schema='auth')
    op.create_table('sso_providers',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('resource_id', sa.TEXT(), autoincrement=False, nullable=True, comment='Auth: Uniquely identifies a SSO provider according to a user-chosen resource ID (case insensitive), useful in infrastructure as code.'),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.CheckConstraint('resource_id = NULL::text OR char_length(resource_id) > 0', name='resource_id not empty'),
    sa.PrimaryKeyConstraint('id', name='sso_providers_pkey'),
    schema='auth',
    comment='Auth: Manages SSO identity provider information; see saml_providers for SAML.'
    )
    op.create_index('sso_providers_resource_id_idx', 'sso_providers', [sa.text('lower(resource_id)')], unique=True, schema='auth')
    op.create_table('mfa_challenges',
    sa.Column('id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('factor_id', sa.UUID(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=False),
    sa.Column('verified_at', postgresql.TIMESTAMP(timezone=True), autoincrement=False, nullable=True),
    sa.Column('ip_address', postgresql.INET(), autoincrement=False, nullable=False),
    sa.Column('otp_code', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('web_authn_session_data', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.ForeignKeyConstraint(['factor_id'], ['auth.mfa_factors.id'], name='mfa_challenges_auth_factor_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='mfa_challenges_pkey'),
    schema='auth',
    comment='auth: stores metadata about challenge requests made'
    )
    op.create_index('mfa_challenge_created_at_idx', 'mfa_challenges', [sa.text('created_at DESC')], unique=False, schema='auth')
    op.create_table('s3_multipart_uploads_parts',
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.Column('upload_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('size', sa.BIGINT(), server_default=sa.text('0'), autoincrement=False, nullable=False),
    sa.Column('part_number', sa.INTEGER(), autoincrement=False, nullable=False),
    sa.Column('bucket_id', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('key', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('etag', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('owner_id', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('version', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('created_at', postgresql.TIMESTAMP(timezone=True), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.ForeignKeyConstraint(['bucket_id'], ['storage.buckets.id'], name='s3_multipart_uploads_parts_bucket_id_fkey'),
    sa.ForeignKeyConstraint(['upload_id'], ['storage.s3_multipart_uploads.id'], name='s3_multipart_uploads_parts_upload_id_fkey', ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id', name='s3_multipart_uploads_parts_pkey'),
    schema='storage'
    )
    op.create_table('messages',
    sa.Column('topic', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('extension', sa.TEXT(), autoincrement=False, nullable=False),
    sa.Column('payload', postgresql.JSONB(astext_type=sa.Text()), autoincrement=False, nullable=True),
    sa.Column('event', sa.TEXT(), autoincrement=False, nullable=True),
    sa.Column('private', sa.BOOLEAN(), server_default=sa.text('false'), autoincrement=False, nullable=True),
    sa.Column('updated_at', postgresql.TIMESTAMP(), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('inserted_at', postgresql.TIMESTAMP(), server_default=sa.text('now()'), autoincrement=False, nullable=False),
    sa.Column('id', sa.UUID(), server_default=sa.text('gen_random_uuid()'), autoincrement=False, nullable=False),
    sa.PrimaryKeyConstraint('id', 'inserted_at', name='messages_pkey'),
    schema='realtime'
    )
    # ### end Alembic commands ###
